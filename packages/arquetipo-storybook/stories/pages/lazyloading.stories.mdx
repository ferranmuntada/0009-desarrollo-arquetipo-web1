import { Meta, Story, Canvas } from '@storybook/addon-docs/blocks';

<Meta title="Lazy Loading"/>

# LAZY LOADING

La siguiente secci칩n pretende explicar como estructurar y mantener el lazy loading dentro de la aplicaci칩n, para ello se explicar치 y se mostrar치 mediante un ejemplo como mantener dicha funcionalidad dentro del proyecto.

## 쯈ue es el Lazy Loading?
El lazy loading o carga en diferido en espa침ol, es un patr칩n de dise침o de programaci칩n cuyo proposito es demorar la carga del contenido multimedia hasta el momento de su uso.

Los beneficios que este patr칩n provee, es que las p치ginas dise침adas respetando esta buena pr치ctica, se cargar치n y renderizar치n m치s rapido que otra que no lo respete, este no es el 칰nico beneficio ya que este factor de carga tambi칠n repercute en el posicionamiento SEO y usabilidad de la web.

## 쮺칩mo aplico el Lazy Loading en mi nueva aplicaci칩n?
Primero que nada, debemos interiorizar que a partir de ahora, cada vez que se genere un componente que acabar치 siendo una vista en la aplicaci칩n angular, se deber치 a침adir para dicho componente un m칩dulo y un routing module. 

Lo usual (y una mala pr치ctica muy frecuente) es que cuando se a침ade un componente nuevo, se a침ade dicho componente al **app.module.ts** y al **app-routing.module.ts**, si bien en aplicaciones peque침as puede que el rendimiento no se vea lastrado, en cuanto nuestro proyecto comience a crecer, se empezar치 a notar una degradaci칩n en el rendimiento, esto se debe a que la aplicaci칩n cargar치 en esta modalidad todo el contenido en cuanto se arranque.

Para evitar esta pr치ctica y como se ha indicado previamente deberemos adoptar el siguiente m칠todo que se explica a continuaci칩n. Para la inclusi칩n y mantenimiento del Lazy Loading deberemos ejecutar las siguientes acciones en caso de estar generando una vista:

Generamos un m칩dulo, para este ejemplo usaremos una aplicaci칩n de administraci칩n:

```sh
ng generate module admin
```
Esto genera una carpeta con el fichero **admin.module.ts** en su interior.

```sh
src
|__app
   |__admin
   |   |__admin.module.ts
   |__app-routing.module.ts
   |__app.component.html
   |__app.component.scss
   |__app.component.spec.ts
   |__app.component.ts
   |__app.module.ts
```

Tras esto generamos dos componentes, login y dashboard

```sh
ng generate component admin/login
ng generate component admin/dashboard
```

Quedando nuestro 치rbol de directorio del siguiente modo:

```sh
src
|__app
   |__admin
   |  |__dashboard
   |  |  |__dashboard.component.html
   |  |  |__dashboard.component.scss
   |  |  |__dashboard.component.spec.ts
   |  |  |__dashboard.component.ts
   |  |__admin
   |  |  |__admin.component.html
   |  |  |__admin.component.scss
   |  |  |__admin.component.spec.ts
   |  |  |__admin.component.ts
   |  |__admin.module.ts
   |__app-routing.module.ts
   |__app.component.html
   |__app.component.scss
   |__app.component.spec.ts
   |__app.component.ts
   |__app.module.ts
```

A침adimos al routing de nuestra aplicaci칩n el path para llegar hasta los componentes generados, y es aqui donde entra la configuraci칩n del lazy loading.

Para configurar esta funcionalidad, Angular provee de una propiedad de routing llamada loadChildren, que especifica la ruta al m칩dulo que necesita ser cargado de manera diferida.

En nuestro ejemplo lo que tenemos que hacer es a침adir la siguiente ruta a nuestro **app-routing.module.ts**:

```js
import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';

const routes: Routes = [
  { path: 'admin', loadChildren: () => import(`./admin/admin.module`).then(m => m.AdminModule) },
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }
```

En este loadChildren se est치 usando la sintaxis de importaci칩n din치mica para el lazy load del m칩dulo de admin.

El siguiente paso es configurar el routing dentro de nuestro nuevo m칩dulo, para ello nos situaremos en la carpeta src/app/admin y crearemos el fichero **admin-routing.module.ts**, al cual le a침adieremos el siguiente c칩digo:

```js
import { NgModule } from '@angular/core';
import { Routes } from '@angular/router';
import { RouterModule } from '@angular/router';

import { LoginComponent } from './login/login.component';
import { DashboardComponent } from './dashboard/dashboard.component';

const routes: Routes = [
    { path: '', component: LoginComponent },
    { path: 'dashboard', component: DashboardComponent }
];

@NgModule({
  imports: [RouterModule.forChild(routes)],
  exports: [RouterModule]
})
export class AdminRoutingModule {}
```

En este fichero de router incluimos las rutas de nuestros componentes de admin, para no entrar en conflictos con el fichero de router general, en vez del m칠todo **forRoot()** utilizamos el m칠todo **forChild()**.

Importamos el **admin-routing.module.ts** quedando dicho m칩dulo como sigue:

```js
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { AdminRoutingModule } from './admin-routing.module';
import { LoginComponent } from './login/login.component';
import { DashboardComponent } from './dashboard/dashboard.component';

@NgModule({
  imports: [
    CommonModule,
    AdminRoutingModule
  ],
  declarations: [ LoginComponent, DashboardComponent],
})
export class AdminModule { }
```

Esto se debe repetir para cada componente o p치gina que realicemos para preservar el lazy loading de cualquiera de las aplicaciones realizadas bajo este arquetipo.
## Author

游녻 **ATSISTEMAS**
